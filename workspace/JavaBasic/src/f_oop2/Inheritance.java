package f_oop2;

public class Inheritance {

	public static void main(String[] args) {

/*		<< 상속 >> 클래스가 가진거 : 변수 혹은 메서드. 상속 : 다른클래스에  내가가진 것을 물려줌.
		- 기존의 클래스를 물려받아 새로운 클래스를 만드는 것이다.
		- 자식 클래스명 extends 부모 클래스명 { }
		- 부모 클래스의 생성자와 초기화 블럭을 제외한 모든 멤버를 물려받는다.
		- 하나의 클래스만 상속받을 수 있다.
		- 상속받지 않는 모든 클래스는 Object 클래스를 상속받는다.
		- 자식클래스는 부모 클래스의 멤버 외의 새로운 멤버를 가질 수 있으므로 자식 클래스는 부모 클래스보다 크거나 같다.
		- 두개 이상의 클래스를 만드는데 공통된 멤버가 있는 경우 부모 클래스로 만든다.
		
		<< super >>
		- 부모 클래스의 인스턴스 주소가 저장된 변수이다.
		- 부모 클래스의 멤버와 자식 클래스의 멤버의 이름이 중복될 때 둘을 구분하기 위해 사용한다.
		
		<< super() >>
		- 생성자에서 부모 클래스의 생성자를 호출하기 위해 사용한다.
		- 자식 클래스 생성자의 첫 줄에 super()가 있어야 한다.
		- 없으면 컴파일러가 자동으로 추가한다.
		
		<< 오버라이딩 >>
		- 상속받은 메서드의 내용을 재정의하는 것이다.
		- 상속받은 메서드와 리턴타입, 메서드명, 파라미터가 같아야한다.
		- 상속받은 메서드보다 좁은 범위의 접근제어자로 변경할 수 없다.
		- 상속받은 메서드보다 많은 예외를 선언할 수 없다.
		- static 을 빼거나 더할 수 없다.
		
		<< 다형성 >>
		- 상속으로 인해 여러가지 형태를 가지게 되는 특징을 말한다.
		- 부모타입으로 생성된 객체는 부모타입에 정의된 멤버만 사용 가능하다.
		- 부모타입과 자식타입은 서로 형변환이 가능하다.
		- 자식타입 -> 부모타입 : Up-casting(생략가능)
		- 부모타입 -> 자식타입 : Down-casting(생략불가)
		- 부모와 자식에 동일한 메서드가 있는 경우 자식의 메서드를 사용한다.(오버라이딩을 한 경우!)
		- 부모와 자식에 동일한 멤버변수가 있는 경우 보모타입에서는 부모의 변수를 자식타입에서는 자식의 변수를 사용한다.
		
				어떤클래스가 에이 메서드를 자식한테물려줘서 자식이 에이메서드를 오버라이딩해서 에이메서드의 내용이 달라진다.
				부모클래스의 객체에서 생성했을때는 에이내용대로되지만, 자식에서했을때는 타입은 부모인데 내용은 자식거야. 
				상속으로인해서 같은이름의 메서든데 이렇게도, 저렇게도 다양한 모습을 가지게 되는 것을 다형성이라고 한다.
				자식타입과 부모타입은 서로 형변환이 가능하다. 부모타입으로 자식타입의 객체생성이 가능.변수는 부모타입인데 객체는 자식인거.
		
		
		<< 접근제어자 >>
		- 외부로부터 데이터를 보호하거나 감추기 위해 사용한다.
		- public 		: 접근에 제한이 없다.
		- protected		: 같은 패키지, 그리고 다른패키지더라도 상속받은 클래스에서 접근이 가능하다.
		- default		: 같은 패키지에서만 접근이 가능하다. 
		- private		: 클래스 내에서만 접근이 가능하다.
		
		<<  Singleton(싱글톤 패턴) >>
		- 객체 생성을 제한하여 하나의 객체만 사용하게 하는 디자인 패턴이다.
		- 객체들간에 객체를 공유하기 위해 사용한다.
		*/
		
		
		
		
		
		
		
		
		
		/*상속의 이유:클래스를 만드는데 변수나 메서드가 중복이 되는거야. 부모클래스하나로 빼줘서 상속을 받게 만들어주는거야. 
		변수와 메서드의 중복을 피하기위해 따로 분리를 해주는 것이다.
		
		오버라이딩: 상속받은 메서드의 내용을 재정의 하는 것.
		@Override//어노테이션
		int method(int a, int b){//리턴타입 메서드명 파라미터 모두 같아야 한다.
		return a + b;
	}*/
		/*
		<< 데이터 >>
		- 8가지 기본형 타입
		- 배열 : 같은타입의 데이터를 여러개 묶어서 사용. 같은타입만 묶어서사용할수있음.
		- 구조체 : 다른 타입의 데이터를 묶어서 사용 (자바에는 없음...)
		- 클래스......변수랑..기능이랑...묶어서...클래스도 데이터야..
		- 다른 타입의 데이터를 묶어서 사용 + 관련메서드
		- 클래스 = 데이터.
		*/
		
		AccessModifier am = new AccessModifier();
		
		System.out.println(am.publicVar);
		am.publicMethod();
		
		System.out.println(am.protectedVar);
		am.protectedMethod();
		
		System.out.println(am.defaultVar);
		am.defaultMethod();
		
		/*System.out.println(am.privateVar);
		am.privateMethod();
		*/
		
		Time t = new Time();
		
		/*t.setHour(16);
		t.setMinute(5);
		t.setSecond(999);
		*///시, 분은 정상범위. 초는 999로함.
		//그냥 변수를 퍼블릭으로하면 잘못된입력을 막을 수 없지만,
		//메서드로 값을 변하게하면 메서드안에 못넣는 로직을 짤 수 있으니까 막을 수 있음.
		//<< 유효성 체크 >> 라고 한다.
		//메서드에 제한을 둘 수도 있다. 다른사람이 이 클래스를 가지고 쓰는데, 다른사람한테 불필요한 메서드는 감추고싶은거야.
		//다른사람이 가져다 쓰면 안되는, 불필요한 TMI 
		//
		
		t.setSecond(100000);
		
		
		System.out.println(t);
		//원래는 참조형타입이어서 주소가 출력되어야하는데, 우리가 입력한 시간이 출력됨. 왜야? toString(Time)에서 정의한 내용
		//toString 을 오버라이딩한거래
		
		
		//싱글톤의 객체를 생성하고싶으면! 싱클톤으로 만들어진 겟인스턴스 . 아무리 객체생성을 많이해도 계속 같은 주소로 돌아간다.
		Singleton s = Singleton.getInstance();
		System.out.println(Singleton.getInstance());//같은애
		System.out.println(Singleton.getInstance());//같은애
		System.out.println(Singleton.getInstance());//같은애
		System.out.println(Singleton.getInstance());//같은애
		
		//싱글톤 아닌건 계속 다른주소나옴.
		System.out.println(new Inheritance());//새객체
		System.out.println(new Inheritance());//새객체
		System.out.println(new Inheritance());//새객체
		System.out.println(new Inheritance());
		System.out.println(new Inheritance());
		
		
		
		
		
		
		
		
		
	}

}
