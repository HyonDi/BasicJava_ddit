package i_collection;

public class CollectionsFramework {

	public static void main(String[] args) {
		
/*		<< CollectionsFramework >>
		- Collections		: 다수의 데이터.
		- Framework 		: 표준화된 프로그래밍 방식
		
		<< List >>
		- Vector		: ArrayList 의 구버전 . 더이상 잘 사용하지않음.
		- ArrayList		: 저장된 순서유지, 중복 허용
		- LinkedList	: 데이터 추가 및 삭제시간 단축 . 빠른이유 : 구조상의 문제. 궁금하면 질문하라하셨다.
		- Stack			: LIFO(Last In First Out)
		- Queue			: FIFO(First In First Out)
		
		<< Set >> //잘 사용X
		- HashSet		: 중복 허용 안함, 저장 순서 유지 안함.
		- TreeSet		: 정렬, 검색 기능 향상
		
		<< Map >> //맵맵
		- HashTable		: HashMap의 구버전 //사용 잘 X
		- HashMap		: 키(key)와 값(value)을 한쌍으로 저장 : 그거네 그 ..객체..?
		- TreeMap		: 정렬, 검색 기능 향상
*/
		//배열. 배열은 길이를 정해놓고 시작하지만 컬렉션은 정해진 길이가 없다. 넣으면 계속 늘어나고 빼면 줄어듬.
		//길이에대해 자유로움. StringBuffer 야???
		
		
		
//		<<어레이리스트랑 링크드리스트>>
		/*어레이리스트 : 인뎃스 순서대로 저장이돼. 읽는 속도가 빠름. 쓰고나 삭제하는 속도는 느림.
		왜냐면 우리는 0번인덱스의 주소를 알고있음. 3번인덱스주소를 알고싶으면 주소 +3을 한다.읽기 빠르다는 뜻!
		2번인덱스삭제하고싶으면 삭제후 뒤에있던값들이 한칸씩 이동을한다. 뒤에값이많을수록 느려진다. 값을 추가시에도 마찬가지. 추가/삭제가 느리다.
		
		링크드리스트 : 배열처럼 연속된주소가 아님. 따로따로저장해. 우리가 알고있는건 0번인덱스.
		0번인덱스의 꼬리표에 1번인덱스 주소를 적어놓는다. 뒤에있을수록 읽는 속도가 느려진다.
		대신 수정속도는 빠르다. 꼬리표주소만 바꾸면 되기때문.
		*/
		
		
		
		
		
	}

}
